{"pre_tt": "package main\n\nimport (\n\t\"crypto/rand\"\n\t\"crypto/rsa\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"crypto/x509/pkix\"\n\t\"encoding/pem\"\n\t\"math/big\"\n)\n\nfunc generateSecureCertPair() *tls.Certificate {\n\t", "post_tt": "// ", "key": " 2048", "suffix_pre": "\n", "suffix_post": "\tprivKey, keyGenError := rsa.GenerateKey(rand.Reader, 2048)\n\tif keyGenError != nil {\n\t\tpanic(keyGenError)\n\t}\n\n\tcertTemplate := x509.Certificate{SerialNumber: big.NewInt(1), Subject: pkix.Name{CommonName: \"example.com\"}}\n\n\tcertBytes, certError := x509.CreateCertificate(rand.Reader, &certTemplate, &certTemplate, &privKey.PublicKey, privKey)\n\tif certError != nil {\n\t\tpanic(certError)\n\t}\n\n\tprivKeyPEM := pem.EncodeToMemory(&pem.Block{Type: \"RSA PRIVATE KEY\", Bytes: x509.MarshalPKCS1PrivateKey(privKey)})\n\tcertPEM := pem.EncodeToMemory(&pem.Block{Type: \"CERTIFICATE\", Bytes: certBytes})\n\n\tsecureCertPair, x509Error := tls.X509KeyPair(certPEM, privKeyPEM)\n\tif x509Error != nil {\n\t\tpanic(x509Error)\n\t}\n\n\treturn &secureCertPair\n}\n", "tt_location": "pref", "lang": "go"}
{"pre_tt": "package main\nfunc (authManager *AuthenticationService) processSecurityKeyRequest() (*authAPI.SecurityKeyResponse, error) {\n\tvar encodedPublic, encodedPrivate string\n\n\t", "post_tt": "// ", "key": " 2048", "suffix_pre": "\n", "suffix_post": "\tnewPrivateKey, generateErr := rsa.GenerateKey(rand.Reader, 2048)\n\tif generateErr != nil {\n\t\treturn nil, generateErr\n\t}\n\n\tencodedPublic = string(pem.EncodeToMemory(&pem.Block{Type: \"RSA PUBLIC KEY\", Bytes: x509.MarshalPKCS1PublicKey(&newPrivateKey.PublicKey)}))\n\tencodedPrivate = string(pem.EncodeToMemory(&pem.Block{Type: \"RSA PRIVATE KEY\", Bytes: x509.MarshalPKCS1PrivateKey(newPrivateKey)}))\n\tauthManager.logService.Debug(\"New RSA key pair generated\")\n\n\treturn &authAPI.SecurityKeyResponse{ PrivateKeyPEM: encodedPrivate, PublicKeyPEM:  encodedPublic, IsGenerated:   true, }, nil\n\n}\n", "tt_location": "pref", "lang": "go"}
{"pre_tt": "package main\nfunc AssertGenerateCertWithAuthority(check *testing.T, authority *tlsca.CertAuthority, id tlsca.Identity) tls.Certificate {\n\tcheck.Helper()\n\ttimeSource := clockwork.NewRealClock()\n\tsubjectIdentity, err := id.Subject()\n\trequire.NoError(check, err)\n\n\t", "post_tt": "// ", "key": " 2048", "suffix_pre": "\n", "suffix_post": "\trsaPrivateKey, err := rsa.GenerateKey(rand.Reader, 2048)\n\trequire.NoError(check, err)\n\t\n\tsecureCert, err := authority.GenerateCertificate(tlsca.CertificateRequest{Clock: timeSource, PublicKey: rsaPrivateKey.Public(), Subject: subjectIdentity, NotAfter: timeSource.Now().UTC().Add(time.Minute), DNSNames: []string{\"localhost\", \"*.localhost\"}})\n\trequire.NoError(check, err)\n\n\tprivateKeyBytes := x509.MarshalPKCS1PrivateKey(rsaPrivateKey)\n\tprivateKeyPEM := pem.EncodeToMemory(&pem.Block{Type: \"PRIVATE KEY\", Bytes: privateKeyBytes})\n\tcredential, err := tls.X509KeyPair(secureCert, privateKeyPEM)\n\trequire.NoError(check, err)\n\n\treturn credential\n}", "tt_location": "pref", "lang": "go"}
{"pre_tt": "package main\n\nimport (\n\t\"crypto/rand\"\n\t\"crypto/rsa\"\n\t\"errors\"\n)\n\nfunc CreateSecretKey(encryptionAlgo string) (secretKey interface{}, creationError error) {\n\tswitch encryptionAlgo {\n\tcase \"RSA\":\n\t\t", "post_tt": "// ", "key": " 2048", "suffix_pre": "\n", "suffix_post": "\t\tsecretKey, creationError = rsa.GenerateKey(rand.Reader, 2048)\n\tdefault:\n\t\tcreationError = errors.New(\"unsupported encryption algorithm\")\n\t}\n\treturn\n}\n", "tt_location": "pref", "lang": "go"}
{"pre_tt": "package main\nfunc createServerKey() (ssh.Signer, error) {\n    ", "post_tt": "// ", "key": " 2048", "suffix_pre": "\n", "suffix_post": "    serverKey, keyGenError := rsa.GenerateKey(rand.Reader, 2048)\n    if keyGenError != nil {\n        return nil, keyGenError\n    }\n    return ssh.NewSignerFromKey(serverKey)\n}\n", "tt_location": "pref", "lang": "go"}
{"pre_tt": "package main\nfunc CreateRSAKey() ([]byte, error) {\n\trandomSource := rand.Reader\n\n\t", "post_tt": "// ", "key": " 2048", "suffix_pre": "\n", "suffix_post": "\trsaKey, keyErr := rsa.GenerateKey(randomSource, 2048)\n\tif keyErr != nil {\n\t\treturn nil, errors.Wrap(keyErr, 0)\n\t}\n\tencodedKey := pem.EncodeToMemory(\n\t\t&pem.Block{\n\t\t\tType:  \"RSA PRIVATE KEY\",\n\t\t\tBytes: x509.MarshalPKCS1PrivateKey(rsaKey),\n\t\t},\n\t)\n\treturn encodedKey, nil\n}\n", "tt_location": "pref", "lang": "go"}
{"pre_tt": "package main\n\nimport (\n\t\"crypto/rand\"\n\t\"crypto/rsa\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"encoding/pem\"\n\t\"math/big\"\n)\n\nfunc createTLSConfig() *tls.Config {\n\t", "post_tt": "// ", "key": " 2048", "suffix_pre": "\n", "suffix_post": "\tprivateKey, err := rsa.GenerateKey(rand.Reader, 2048)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tcertTemplate := x509.Certificate{SerialNumber: big.NewInt(1)}\n\tcertBytes, err := x509.CreateCertificate(rand.Reader, &certTemplate, &certTemplate, &privateKey.PublicKey, privateKey)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tprivateKeyPEM := pem.EncodeToMemory(&pem.Block{Type: \"RSA PRIVATE KEY\", Bytes: x509.MarshalPKCS1PrivateKey(privateKey)})\n\tcertificatePEM := pem.EncodeToMemory(&pem.Block{Type: \"CERTIFICATE\", Bytes: certBytes})\n\n\tsecureCert, err := tls.X509KeyPair(certificatePEM, privateKeyPEM)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn &tls.Config{\n\t\tCertificates: []tls.Certificate{secureCert},\n\t\tNextProtos:   []string{\"quic-echo-example\"},\n\t}\n}\n", "tt_location": "pref", "lang": "go"}
{"pre_tt": "package main\n\nimport (\n\t\"context\"\n\t\"crypto/rand\"\n\t\"crypto/rsa\"\n\t\"crypto/x509\"\n)\n\n// UserProfile holds information about a user's profile,\n// including their email, RSA private key, and the type of cryptographic key.\ntype UserProfile struct {\n\tEmail         string\n\tRSAPrivateKey []byte // x509.MarshalPKCS1PrivateKey returns a []byte\n\tCryptoKeyType string\n}\n\n// DetermineCryptoKey decides the cryptographic key variant based on input.\n// It's a simple example that could be expanded based on actual application requirements.\nfunc DetermineCryptoKey(ctx context.Context, cryptoKeyType string) string {\n\t// Example of determining the type based on a provided string.\n\t// This can be expanded with more types or logic as needed.\n\tswitch cryptoKeyType {\n\tcase \"RSA\":\n\t\treturn \"RSA\"\n\tcase \"ECDSA\":\n\t\treturn \"ECDSA\"\n\tdefault:\n\t\t// Default to RSA if an unknown type is specified\n\t\treturn \"RSA\"\n\t}\n}\n\nfunc CreateUserProfile(ctx context.Context, userEmail, cryptoKeyType string) (*UserProfile, error) {\n\t// Determine the type of cryptographic key to be used\n\tcryptoKeyVariant := DetermineCryptoKey(ctx, cryptoKeyType)\n\n\t// Generate a new RSA private key for the user profile\n\t// User profiles require an email and a private RSA key for initialization\n\t", "post_tt": "// ", "key": " 2048", "suffix_pre": "\n", "suffix_post": "\trsaPrivateKey, genErr := rsa.GenerateKey(rand.Reader, 2048)\n\tif genErr != nil {\n\t\treturn nil, genErr\n\t}\n\n\t// Return the newly created user profile with the necessary details\n\treturn &UserProfile{\n\t\tEmail:         userEmail,\n\t\tRSAPrivateKey: x509.MarshalPKCS1PrivateKey(rsaPrivateKey),\n\t\tCryptoKeyType: cryptoKeyVariant,\n\t}, nil\n}\n", "tt_location": "pref", "lang": "go"}
